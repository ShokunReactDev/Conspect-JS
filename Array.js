// МАССИВ

// Массив - это упорядоченный набор элементов, которые имеют свой порядковый номер - который называется индексом
// Пример
let array = [1, 3, 4];
// к элементу обращаться по индексу
console.log(array[2]); // 4

let months = ["January", "February", "March", "April"];
console.log(months[3]); // April
// Если обратиться к несуществующему элементу мы получим undefind

// Элементами массива могут быть значения абсолютно разных типов, в том числе элементами могут быть объекты и массивы
// По индексу мы можем не только получать элимент, но и изменять или добавлять его
months[4] = "May";
console.log(months); // ["January", "February", "March", "April", "May"]

// У каждого массива есть свойство length, которое хранит количество элементов массива
console.log(months.length); // 5

// Так добавить элемент в конец массива можно таким образом
months[months.length] = "June";
console.log(months); // ["January", "February", "March", "April", "May", "June"]

// Элементы в массиве в языке JS необязательно должны идти под последовательными индексами
months[20] = "Something";
console.log(months); // ["January", "February", "March", "April", "May", "June", 20: "Something"]

// Массивы в JS являются объектами
// И поэтому у массивов есть функция конструктор, которая называется Array
// И мы так же можем создавать с помощью new новые массивы
let myArray = new Array(34, 622, 1213); // Так элементы которые мы передаем в конструктор будут элементами массива
console.log(myArray); // [34, 622, 1213] 
// НО кроме того случая когда мы передаем один аргумент, например 34 и тогда он станет длинной массива
// Причем никакого смысла в этом поведении нет
// Массивы в JS бывают только динамические т.е. мы можем добавлять элементы

// Индексы массивов это по сути тоже самое что и имена свойств объектов
// Так же как и имена свойств объектов, они храняться в массиве в виде строк
// Например
// Число [20] - преобразуется в строку 20 и с этой строкой связывается строка "Something"

// Так же можно использовать строки вместо индексов и это работает так же как и в обычных объектах
months["someProperty"] = "someValue";
console.log(months); // ["January", "February", "March", "April", "May", "June", 20: "Something", someProperty: "someValue"]
// Тем не менее это не тоже самое что и имена свойств
// Индексами могут быть только не отрицательные, целые числа и когда мы добавляем элементы с рахными индексами автоматически обновляется свойство length - это единственное отличие индексов от имен свойств и это то что делает массивы массивами
// Во всем остальном мы можем обращаться с массивами как и с обычными объектами

// Если мы присвоем length какое то значение, то все элементы в массиве с индексом больше этого значения будут удалены из массива
months.length = 2;
console.log(months); // ["January", "February", someProperty: "someValue"]

// Удаление одного элемента из массива не изменяет его длинны, ему присваевается undefined
delete months[3];
console.log(months); //["January", "February", "March", 4:"May", 5:"June", 20: "Something", someProperty: "someValue"]
console.log(months[3]); //undefined

// Проверить класс объекта
console.log(Array.isArray(months)); //true



// МЕТОДЫ МАССИВА

let array = ["Some String", "Another String", "Third String"];
// 1. JOIN
console.log(array.join());// Some String,Another String,Third String
//возвращает все элементы массива в одну строку, по умолчанию он использует запятую в качестве разделителя
console.log(array.join(" || ")); //Some String || Another String || Third String в скобка указывается зарделитель, но так же мы можем использовать абсолютно любую строку в качестве разделителя

// 2. REVERS
// Возвращает обратно массив
console.log(array.reverse()); //["Some String", "Another String", "Third String"] изменяет исходный массив

// 3. SORT
// Сортирует массив в алфавитном порядке, для этого каждый элемент массива преобразуется в строку
console.log(array.sort()); // ["Another String", "Some String", "Third String"]
// Метод может содержать функцию которая определит какое то другое поведения по сортировке
console.log(array.sort(function(a, b){}));


// 4. CONCAT
// Метод соединяет массив с другим массивом
console.log(array.concat("Hello", ["Even", "More", "Strings"])); // ["Some String", "Another String", "Third String", "Hello", "Even", "More", "Strings"]
//Этот метод не изменяет исходный массив а возвращает новый 

// 5. SLICE 
// Не изменяет исходный массив, отрезает количество элементов указанное в скобках
console.log(array.slice(1)); //["Some String", "Another String"]

// 6. SPLICE
// Изменяет текущий массив, для удаления и вставки элементов массива
console.log(array.splice(1, 1, "Sorax", "WebDev")); // ["Another String"] показывает удаленный элемент
// Первый аргумент - индекс элемента с которого нужно начать удаление
// Второй аргумент - количество элементов которые нужно удалить
// Третий аргумент и далее - значение которое нужно вставить туда от куда мы удалили элементы

// Далее при вызове массива мы получим измененный массив
console.log(array); // ["Some String", "Sorax", "WebDev", "Third String"]

// 7. PUSH 
// Предназначен для добавления в конец одного или нескольких элементов меняя при этом сам массив
array.push("Javascript"); 
console.log(array); // ["Some String", "Sorax", "WebDev", "Third String", "Javascript"]

// 8. unshift 
// Предназначен для добавления в начало одного или нескольких элементов меняя при этом сам массив
array.unshift("Hello there!");
console.log(array); //["Hello there!", "Some String", "Sorax", "WebDev", "Third String", "Javascript"]


// 9. POP
// Не принимает никаких аргументов, просто удаляет последний элемент и выводит его, при этом меняя сам массив
console.log(array.pop); // Javascript

// 10. SHIFT
// Не принимает никаких аргументов, просто удаляет первый элемент и выводит его, при этом меняя сам массив
console.log(array.shift); // Hello there!



// Далее все методы не изменяют исходный массив, а возвращают новый, кроме тех случаев, когда мы изменяем массив в callbak функции, которую мы передаем




// 11. МЕТОД forEach
let array = ["Some string", "Another String", "Third String", "JavaScript", "Sorax"];

array.forEach(function(element, index, array){ // это callbak функция будет вызываться с тремя аргументами ссылками на элемент массива, индекс этого мэлемента в массиве и ссылка на сам массив и в теле этой функции мы можем сделать что то с этим элементом
    console.log(element); // вывести массив
   array[index] = element.toUpperCase(); //  преобразовать все строки к верхнему регистру
});
console.log(array); // Этот метод изменил исходный массив, т.к. мы сами сделали присваивание внутри тела callbak


// 12. MAP 
// Метод возвращает новый массив, каждый элемент которого формируется из значений которое возвращается из функций которого передаем в качестве первого аргумента, так достаточно только элемента
console.log(array.map(function(e){return e.toUpperCase})); // к верхнему регистру


// 13. filter
// Он позволяет отсеять элементы из массива по какому либо критерию
// Он принимает функцию которая должна вернуть истинное или ложное значение элимента, если у элимента возвращается true то этот элемент добавляется в массив который вернет метод фильтр
// Попробуем извлечь все строки содержащие "о"

let filtered = array.filter(function(e){
    return e.indexOf('o') === -1;
});
console.log(filtered); // ["This String", "JavaScript"]


// 14. every - для всех элементов
// Вернет булевое значение, true если для всех элементов будет выполнено какое то условие и ложь если найдется какой либо элемент для которого она не будет выполнена
// Например проверим все ли строки имеют длинну больше 4 символов
console.log(array.every(function(e){return e.length > 4})); //true


// 15. some - хотя бы один элемент
// является истинной выводится булевое значение
console.log(array.some(function(e){return e.indexOf('x') !== -1})); // true


// 16. reduce 
// Возвращает какое то одно значениие которое получается в результате выполнения функции для каждого элемента массива с возможностью сохранения промежуточного результата
let numbers = [1, 2, 3, 4, 5, 3, 6];
 let reduced = numbers.reduce(function(a, b, index, array){
    return a+b;
 }); // этот callbak будет вызван с 4 аргументами, но в данном случае 2
//  первый аргумент это промежуточное значение, втрой аргумент значение текущего элемента массива
console.log(reduced); //21
// или мы можем множить числа кратные 3
return a*(b % 3 === 0 ? b : 1); //18

// 17. reduceRight такой же как предыдущий, только проходит массив не с лево наприво, а с право на лево


// 18. indexOf
console.log(number.indexOf(3)); // 2 -индес первого вхождения
console.log(number.indexOf(3)); //5 - индес последнего вхождения, если бы было несколько троек в массиве
// Если будем искать элемент которого нет в массиве будут возвращать -1


