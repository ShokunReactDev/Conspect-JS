// РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ

// РВ - называется объект, который описывает набор символов или символьный шаблон, который можно использовать для поиска подстрок в каком либо тексте
// Это просто язык для описания шаблонов, который задает правило поиска в тексте 

// Все буквы и цифры в регулярных выражениях описываются в падение буквально
// Литералы в РВ выделяются /  / слэшами
// После закрывающего слэша будут прописаны флаги 
// gl - global и т.д

// При помощи [] - мы можем объеденить символы в классы
// Например [aoeiuy] - мы найдем в тексте все глассные буквы
// [A-Z] - все заглавные буквы, так же диапазоны цифр
// При [^0-9] наоборот все что не входит в этот промежуток - т.е буквы

// Сокращения
// [0-9] => \d
// [^0-9] => \D - любой символ кроме цифр
// \w - все символы которые являются буквами или цифрами
// \W - все символы которые не являются буквами или цифрами (знаки препинания)
// \s - все пустые символы (пробелы, табуляции, переносы строк)
// \S - все символы которые не являются пустыми символами
//  \b - граница слова, т.е если мы хотим найти именно слова an => \ban\b
// \B - находятся те которые в середине слова
// me|and - Логическое или что бы найти либо то либо то
// и что бы это были слова мы так же должны добавить \b => \bme\b|\band\b
// Если слова одинаковые кроме одной буквы => gr(e|a)y или gr[ae]y
// Если при поиске символ не обязателене => colou?r

// . - точка выделяет любой символ, кроме переноса строк
// Если нужно найти саму точку => \.
// Если начало на а конец е, а между ними 4 символа => a....e или a.{4}e  -   от и до через запятую

// Повторение в РВ бывает жадным и не жадным - т.е. будут повторяться столько сколько возможно зависит от того есть ?(не жадные) или нет
// Что бы сделать повторение не жадным => a.{4,10}?e
// От двух и более раз a.{1,}e или a.+?e или a.*?e

// Помимо границы слова \b мы можем указать начало или конец строки при этом включим регистр независимый поиск флаг - IgnoreCase
// Но если не стоит флаг - multiline - начало строки считается начало всего нашего текста 
// и пишем для нахождения начало строки => ^that
// Для нахождения в конце строк $ => \.$


// Positive lookahead - вперед смотрящее утверждение
// Например мы хотим найти слово and после которого есть пробел и слово he => and(?=he) - все что после ровно мы хотим найти
// Negative lookahead - вперед смотрящее отрицание
// Например все to после которых нет слова know => \bto\b(?!know)


// Группы
// Например у нас есть несколько мейлов и мы хотим их найти и так же мы хотим выделить именна ящиков и домены
// (\b\w+)@(\w+\.\w+\b) - две группы - запоминаюющие группы
// Что бы найти java и javaScript => java(script)? что бы не создавалась запоминающая группа нужно написать java(?:script)?



// КАК ИСПОЛЬЗОВАТЬ РВ В JS (методы)

// Для работы с РВ есть специальный класс RegExp
let pattern = new RegExp("\w", "gim"); //его конструктор принимает два параметра - первый - строка которая содержит РВ и второй - строка которая содержит флаги
let samePattern = /\w+/gim; // мы написали тоже самое что и в верхнем, но так предпочтительней использовать

let pattern = /\w+/g,
    string = "How we survive is what make us who we are";

console.log(string.match(pattern)); // возвращает массив, так как стоит global мы получаем массив всех метчей,
// если мы его уберем то получим метч только первого слова с идексом и инпутом

console.log(string.search(pattern)); // 0 - всегда возвращает индекс первого метча - принимает РВ и игнорирует глобал

console.log(string.split(/[\s,]+/)); // массив - если бы в строке было много пробеллов или запятые то мы не смоглибы использовать 
// обычную строку в виде разделителя, вместо нее регулярное выражение, нужно заметчить какое то количество пробелов и запятых один и более раз

// еще метод replace, кторый может заменять выражение в скобках например на эту строку
input.addEventListener('keyup', function(){
    output.innerHTML = this.value.replace(
        /\{\{(\w*)\}\}/g, "Some string"
    );
}, falce);



// Сам класс RegExp

let pattern = /\w+/g;

console.log(pattern.global); //true
console.log(pattern.ignoreCase); //false
console.log(pattern.multiline); //false
// Через которые можно посмотреть установленны ли соответствующие флаги и мы не можем изменять их на существующих РВ

console.log(pattern.lastIndex); // 0 - который используется методом класса RegExp для хранения индкса последнего результата


// Метод тест - он принимает строку в качестве аргумента и возвращает истинну в том случае если в этой строке есть символы соответствующие РВ
let pattern = /\w+@\w+\.\w+/,
    string = "Lorem ipsum dolor sit amet, aoue@uou.com onsectetur adipisicing elit. In distinctio ex tenetur, odio reiciendis fuga voluptatum magni pariatur consequuntur odit qui illum impedit suscipit quaerat architecto atque nesciunt voluptas, soluta eaque nihil accusantium temporibus ipsam dolores repellat veritatis? A suscipit, asperiores sequi nihil consequatur, quibusdam magnam, sed cumque reiciendis ratione quisquam eius quia architecto quas quam excepturi voluptatum unde quod temporibus illo nam ab magni! Facere tempore, ea ducimus quis.";

console.log(pattern.test(string)); //true
// Если в тексте будет мейл вернется true, если нет вернется false
// Метод тест можно использовать например при валидации форм
// Но если в РВ будет указана g - глобал, то при повторном тесте уже будет false


// Метод exec - дает индесы удобно использовать в цикле 
let pattern = /\w/g,
    string = "How we survive is what makes us who we are";

while (match = pattern.exec(string)) {
    console.log(math[0] + " (Index: " + math.index + ")"); //выводится каждое слово с индексом его начала по буквам How(Index: 0) we(Index: 4) и т.д
}


let pattern = /(\w+)@(\w+\.\w+)/g,
    string = "How we sorax@domain.com survive",
    math;

while (math = pattern.exec(string)) {
    console.log("Name: " + math[1] + ", Domain " + math[2]); // Name: Sorax, Domain: domain.com
}



