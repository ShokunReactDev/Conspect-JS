// Типы данных:
// -Number
// -String
// -Boolean
// -null
// -Object
// -Simbol
// -Undefind


// Number
// Metod - toFixed добавляет знаки после целого числа "."
// - toExponential для перевода в ехпоненсиальную форму
// - toPrecision выводит количество чисел - точное 
// АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ
// Унарные -10 и +10
// Ибимента и дикримента ++ -- меняют переменную на 1
// есть префиксный и постфиксный ++i или i++
// Бинарные операторы + = * / -
// Остаток от деления %
// n+=2 вместо n=n+2
// Операторы отношения > < = возвращают boolean


// Math.sqrt - квадратный корень
// Math.row - возведение в степень
// есть числа пи и е


// STRING

// Перенос строки в файле\ в консоле\n для табуляции \n\t
// Кавычки что бы читались - \"

// Metods
// - string.charAt(0) возвращает символ
// - Длинна строки - .length
// - string.substring(10,21) возвращает от и до какого символа
// - Похожие .slice .substr
// - string.indexOf("i") возвращает индес буквы
// - string.replace заменить строку("is","is not")
// - string.split(" ") разбирает строку на массив - в данном случае через пробел
// - string.toUpperCase приведение к верхнему регистру
// - string.toLowerCase приведение к нижнему регистру

// BOOLEAN

// При сравнениях
// true && false => false
// true && false => true
// true || false => true
// !true => falce
// !falce => true


// NULL UNDEFIND
// Отсутствие значения 
// null - пустое значение
// undefind - полное отсутствие какого либо значения, несуществующий элемент или свойство


// ПРЕОБРАЗОВАНИЕ ТИПОВ
// Конструктор 	console.log(Number("555")) => console.log(+"555")
// 		console.log(String(555))   => console.log(555 + "")
// 		console.log(Boolean(555))  => console.log(!!555)
// Еще один метод Number => String : 	const number = 22;
// 					number.toString()
// Аналогично false.toString()

// String => Number : 	console.log(parseInt("45", 10//10-это система исчисления))
// 			console.log(parseFloat("12.45 em"))


// УСЛОВНЫЕ ИНСТРУКЦИИ

// - if(выражение) инструкция - если выражение истинное инструкция выполняется
// Если выражение не истинное else (можно еще добавлять if)

// Пример:

let a = 20;


if(a>10){
	text = "x больше 10";
} else if (a<10){
	text = "х меньше 10";
}else{
	text = "х равен 10";
}

// - switch(выражение){
// 	case выражение: инструкции
// 	default выражение: инструкции
// } - switch(выражение) будет сравнивать выражение с case, когда совпадет будет выполнена инструкция, а так же все остальные инструкции которые стоят ниже
// Если выражение не равно ни одному case, будет выполняться инструкция default

// Пример:
let name = "Sorax", homecity;

switch(name) {
	case "John": homecity = "Boston"; break
	case "Sorax": homecity = "Belgorod"; break
	case "Bill": homecity = "LA"; 
	default: homecity = "Moscow";
}
console.log(homecity);

// break - инструкция мгновенного выхода из цикла switch


// УСЛОВНЫЙ ОПЕРАТОР

// выражение1(условие) ? выражение2 : выражение3
// выражение1 - преобразуется в boolean и если true => возвращает выражание2, если false => возвращает выражение3

// Пример:
let x = 15;
let text = x > 10 ? "х больше 10" : "х меньше либо равен 10";
console.log(text);
// или
let x = 15;
let text = x > 10 ? "х больше 10" : х <10 ? "х меньше 10" : "х равен 10";
console.log(text);

// , - бинарный оператор
// выражение, выражение - вычисляет значение левого и правого апперанта и возвращает значение правого апперанта



// ФУНКЦИИ

// function идентификатор /это имя нашей функции/ (аргументы/переменные которые передаем в функцию/) {инструкции}

// Пример:
function greet(name) {
	return "Hello" + name;
}

// Вызов функции: выражение(аргумент)
console.log(greet("Sorax")//еще можно добавить метод .toUpperCase()/);
// Если функция ничего не возвращает - Undefind

// Так же функцию можно определить если присвоить переменной выражение определение функции
// Пример аноннимной функции:
const greet = function (name) {
	return "Hello" + name;
}; //важно после такой функции ;

// При этом 
console.log(greet("Sorax") => console.log(greet("Sorax", 22, 33, 44) //- не будет выводиться в console, но при:
const greet = function (name) {
	console.log(arguments); //- в console ["Sorax", 22, 33, 44] //массив, в котором можно обратиться по индексу [i] или метод .length
 	return "Hello" + name;
};

// Т.к. функции это объекты, мы можем передавать функции в функции в качестве аргументов, а так же возвращать функции из функций для передачи callback
// Пример:
let func = function(callback){
	let name = "Sorax";
	callback(name);
};

func(function(n){
	console.log("Hello" + n);
}); 

// И возвращающим значением
// Пример:
let func = function(){
	return function(){
	console.log("Hi");
	}
};

// Вызвать 
func()();

// Аноннимная самовызывающая функция
// Пример:
let greeting = (function(name){
	return "Hello" + name;
}("Sorax"));
console.log(greeting);


// ЦЕПОЧКИ ОБЛАСТЕЙ ВИДИМОСТИ

// Область видимости переменной - это часть программы где эта переменная определена и доступна, делится на:
// - Глобальные - переменные объявленные вне каких либо функций
// - Локальные - переменные объявленные внутри функции
// Вложенные функции создают цепочки областей видимости

// Hosting переменных


// ЗАМЫКАНИЯ

// Благодаря наличию внутренней функции, интерпретатор продолжает хранить значения переменных внешней функции, даже после её завершения.
// Лексическая область видимости - каждую функцию можно назвать замыкания
// Пример:
let counter = (function(){
	let count = 0;
	return function(){
	return count++;
}
}());
console.log(counter()); //=> 0
console.log(counter()); //=> 1
console.log(counter()); //=> 2
// Не принимает никаких аргументов выдает при этом разные значения при разных вызовах
// Позволяют сделать функцию для сохраниния и инкапсуляции данных
// Так же можно обнулить счетчик или добавить число с которого начнется расчет
// Пример:
let counter = (function(){
	let count = 0;
	return function(num){
	count = num !== undefined ? num : count;
	return count++;
}
}());
console.log(counter()); //=> 0
console.log(counter()); //=> 1
console.log(counter()); //=> 2
console.log(counter(20)); //=> 20
console.log(counter()); //=> 21
console.log(counter()); //=> 22

// Такое же поведение при другой реализации
// Пример:
let counter = function(num){
	counter.count = num !== undefined ? num : counter.count;
};
counter.count = 0;


// ОБРАБОТКА ИСКЛЮЧЕНИЙ

// Инструкция throw - создает исключения
throw выражение
// Пример:
throw "Hello" //Это исключения при которых браузер будет выдавать ошибку
// Пример:
let calculate = function(n){
	if(n>10) throw new Error("n should be less than 10")
return n + 10;
};
calculate(20);  
// Важно использовать исключения только в крайних случаях, когда на правильности данных держиться весь смысл нашего кода

// Инструкция try/catch/finally - обрабатывает исключения
// Пример:
try{				//блок catch или finally могут отсутствовать, но не оба сразу
	// инструкции которые могут бросить исключения
} catch (идентификатор) {  //ловим это исключение
	//инструкции  / которые будут выполняться только в том случае если в try произошло исключение
} finally {
	//инструкции  / будут выполняться независимо произошли какие то исключения или нет, будут выполняться
}

// Пример:
try{
	calculate(20);
} catch(e) {
	console.log("Can't execute calculate:" + e.message);
}


// Диалоговые окна 
// ВЗАИМОДЕЙСТВИЯ alert, promt, confirm
// alert - показывает сообщение и ждет, когда пользователь нажемет ОК
// Пример
alert("Hello");

// promt - принимает два аргумента
// Пример
result = prompt(title, [default]);//отобразит модальное окно с текстом из поля title и начальное значение в поле [default]
// в поле пользователь может написать значение, которое будет присвоенно result
// при отмене значение result будет null

// confirm - отоброжает модальное окно с текстом вопроса и двумя кнопками ОК и отмена
// результат true при нажатие ок, в других случаях false
// Пример
// result = confirm(вопрос);
let isBoss = confirm("Ты здесь главный?");
alert( isBoss );




//  АКСЕССОРЫ И АТРИБУТЫ СВОЙСТВ

// Для аксессоров в объектном литирале предусмотрен специальный синтаксис
// Пример
let person = {
    name: "Sorax",
    get age(){}, //геттер и сеттер и эта пара функций заменит нам свойство age
    set age(){}, 
};
//когда мы будем пытаться обратиться к свойству age будет вызвана специальная функция и когда мы будем пытаться изменить ее значение будет вызываться функция set
// Пример
let person = {
    name: "Sorax",
    get age(){
        return "Hello from getter!";
    }, 
    set age(){}, 
};
console.log(person.age);//Hello from getter!

// так же мы можем не возвращать что то на прямую, а просто вывести что то в консоль
// Пример
let person = {
    name: "Sorax",
    get age(){
        console.log("Hello from getter!");
    }, 
    set age(){}, 
};
person.age;//Hello from getter!

// сеттер принимает значения и внутри него мы можем что угодно делать этим значением, например присвоить его свойство нашему объекту
// Пример
let person = {
    name: "Sorax",
    _age: 20,
    get age(){
        return this._age;
    }, 
    set age(value){
        this._age = value
    }, 
};
console.log(person.age);//20
// Так эти два метода реализуют стандартное поведение и так же это работает когда мы используем обычные свойства
// Но здесь так же мы можем сделать проверку данных
// Пример что бы не возможно было установить возраст меньше 0 или больше какого то значения
let person = {
    name: "Sorax",
    _age: 20,
    get age(){
        return this._age;
    }, 
    set age(value){
        this._age = value < 0 ? 0 : value > 122 ? 122 : value;
    }, 
};
person.age = 180;
console.log(person.age);//122
person.age = -80;
console.log(person.age)//0
person.age = 34;
console.log(person.age)//34


// АТРИБУТЫ writable enumerable configurable
// Каждое свойство имеет имя и значение, кроме этого оно имеет атрибуты
// Эти три атрибута, как и само значение свойства которое называется атрибутом value можно получать и изменять при помощи объкта который называется дескриптором свойства(это самый обычный объект, его ничего не отличает от остальных объектов, его просто назвали дескриптором для удобства)
// Для того что бы получить этот дескриптор достаточно воспользоваться статическим методом
Object.getOwnPropertyDescriptor(person, "name"); // первый аргумент это объект, второй аргумент это имя свойства
console.log(Object.getOwnPropertyDescriptor(person, "name")); //Object {value: "Sorax", writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptor(person, "age")); //Object {get: function, set: function, enumerable: true, configurable: true}
// В дескрипторе аксессора есть методы get set в дескрипторе обычного свойства есть атрибуты value writable 
// В аксессоре нет атрибута writable, т.к. доступность для записи определяется наличием или отсутствием сеттера


// Для определения или переопределения атрибутов свойств мы можем использовать статический метод
Object.defineProperty(person, "gender",{
    value: "male",
    writable: false,
    enumerable: false,
    configurable: false
}); //принимает три параметра: объект, свойство и дискриптор
console.log(person.gender); // male 
// т.к. мы поставили writable: false, если мы попробуем изменить это свойство то мы увидим что у нас ничего не получится 
person.gender = "female";
console.log(person.gender); // male 


// for...in
// for ( идентификатор, который будет использоваться для отдельных свойств объекта in объект ) {тело цикла}
for (property in person) {
    console.log(property); //age  т.е. мы выводим в консоль все свойства объекта
};
// Если у свойства стоит enumerable: false => свойство не выводится, если поменять на true
console.log(Object.keys(person));//["name", "_age", "age"] массив перечисляемых свойств 

console.log(person.propertyIsEnumerable("gender")); //false для проверки атрибута Enumerable вызывается у самого объекта true только для ненаследуемых свойств

// Расширяемость объекта
// Для проверки статический метод 
// Пример
let obj = {};
console.log(Object.isExtensible(obj));//true
// Но если пропустить через статический метод
Object.preventExtensions(obj);
console.log(Object.isExtensible(obj));//false этот метод делает нерасширяемым сам объект
Object.seal(obj); //не сможем добавлять, удалять свойства менять значения атрибута свойств
console.log(Object.isSealed(obj)); //Проверить был ли применен этот метод

Object.freeze(obj); //тоже самое + все свойства доступны только для чтения
console.log(Object.isFrozen(obj)); //помогает проверить заморожен ли объект




// JSON

// Сириализация объектов - это преобразование объектов в строки, нужно для хранения и передачи информации
// Если нужно получять какие то данные с сервера во премя работы приложения то можно использовать JSON 
// Или хранить в нем данные локально использую localStorage
// В нем можно хранить объекты, массивы, строки, числа, true, false, null => любые другие значения преобразуются в null

// Для преобразования объектов в строку в JSON используют JSON.stringify
// Пример
let user = {
    name: "Frank",
    id: 4324
};

let userData = JSON.stringify(user);
console.log(userData); // {"name": "Frank", "id": 4324}
console.log(typeofuserData); //string

// Из строки в объект JSON.parse
// Пример
console.log(JSON.parse(userData)); // Object {name: "Frank", id: 4324}

// Если мы хотим скрыть какие то объекты, например ID в объект пишем то что хоти показывать

toJSON: function(){
    return{
        name: this.name,
        lastVisit: this.lastVisit
    }
}



// ОБЪЕКТ Math

// Метод pow для возведения числа в самопроизвольную степень
console.log(Math.pow(2,5)); // 32 | первый аргумент это число и второй аргумент это степень в которую его нужно возвести

// Метод sqrt возвращает квадратный корень числа (Square Root)
console.log(Math.sqrt(9)); //3

// Метод abc для того что бы взять модуль числа - абсолютную величену(Absolute)
console.log(Math.abs(300)); //300
console.log(Math.abs(-300)); //300

// Метод round для округления целого числа, если больше 0.5 к большему числа, если меньше к меньшему числу
console.log(Math.round(9.6)); // 10
console.log(Math.round(9.2)); // 9

// Метод floor Для округления только в меньшую сторону
console.log(Math.floor(9.6)); // 9

//Метод ceil Для округления только в большую сторону
console.log(Math.ceil(9.2)); // 10

// Методы min max будут возвращать меньшее или большее число из аргументов
console.log(Math.min(6, 9, 2, 5)); // 2
console.log(Math.max(6, 9, 2, 5)); // 9

// Метод exp возводит число в е указанную степень
console.log(Math.exp(1)); //2.718281828459045

// Метод log возвращает натуральный логарифм числа

// Тригонометрические методы синус - sin, косинус - cos, тангенс - tan
// Арктангенс - atan, арксинус - asin, арккосинус - acos

// Так же есть константы пи - PI, константа е - Е


// Метод random - этот метод не принимает никаких аргументов, а выносит любое число от 0 до 1
console.log(Math.random()); // 0.82 
// Число от -10 до 10
console.log(-10 + Math.random()*20); //-2
// т.к. это неудобно писать можно написать функцию с мин и мах
let getRandom = function(min, max){
    return Math.random() * (max - min) + min;
};

console.log(getRandom(10,20)); // 14.06 | с помощью такой функции мы можем получать произвольные числа в любом диапозоне



// КЛАСС Date

// Предназначен для работы с датой и временем
let date = new DataTransfer();
console.log(date); //Fri Oct 04 2013 17:21:25 GMT+0400 (MSK) | мы получаем дату и время создания текущего объекта, а так же часовой пояс
// Но при помощи аргументов мы можем указать дату которую хотим хранить в этом объекте
let date = new DataTransfer(1990, 0, 1); // первый аргумент то год, второй месяц - номирация начинается с 0 и день, дальше часы, минуты, секунды, милесекунды 
console.log(date);

// Так же мы можем вызвать любой из аргументов с помощью get таким образом
console.log(date.getMilliseconds()); // getHours, getMinutes, getSeconds, getDay, getDate, getMonth, getYear, getFullYear




// Strict Mode - директив 'use strict';
// Подмножество JS для устранения некоторых слабых мест в языке, упрощения отладки и улучшения безопасности 
// Мы не можем использовать with
// При попытке использовать не объявленные переменные ошибка
// Если мы попробуем изменить свойство только для чтения получим ошибку
// И так же мы получим ошибку, если после preventExtensions попробуем добавить объекту новое свойство
// Или удалить свойство с configurable: false
// В объектах не может быть свойств с одним и тем же именем

// Основная задумка в том что бы упростить отладку скриптов, выдавая ошибки там где обычный режим будет просто молчать 
// Такое поведение интерпритатора в стандартном режиме, когда в большенстве случаев попытки сделать что то неправильно просто игнорируются 



